{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"2023/12/10/we-have-a-blog-now/","title":"We have a blog now!","text":"<p>This weekend I have spent some time to make some updates to the Rzk website. In particular, we now have multi-lingual support (with some significant portions translated to Russian) as well as a blog system, where we plan to regularly post about changes and improvements to Rzk, tooling, and related formalization projects.</p> <p>The blog supports literate Rzk files:</p> <pre><code>#lang rzk-1\n#define hello-world\n  : U\n  := (hello : U) \u2192 hello\n</code></pre>"},{"location":"2023/12/24/rzk-formatter/","title":"Rzk Formatter","text":"<p>Version 0.7.0 (and later 0.7.3 with bug fixes) of Rzk has recently been released, and it brings with it an exciting new feature: the auto formatter! It has been under work for over 3 weeks and came with unique design challenges that I will attempt to unpack in this post.</p>"},{"location":"2023/12/24/rzk-formatter/#goal","title":"Goal","text":"<p>Basically, the target is to write a program that takes in Rzk code as input and makes sure it abides by the style guide (developed mainly by Fredrik Bakke and other contributors to the sHoTT project) with minimal modification otherwise. For example, comments should stay intact and semantics should be preserved.</p> <p>We decided to not support any customization (at least initially), making the formatter heavily opinionated.</p>"},{"location":"2023/12/24/rzk-formatter/#challenges","title":"Challenges","text":"<p>Designing a formatter has both technical and nontechnical challenges. From the nontechnical side, and especially since the formatter is not customizable, there is the challenge of having the formatting requirements formulated in a precise enough language that can be translated easily into code, assuming there is even consensus among the community on these requirements.</p> <p>From the technical perspective, the parser generator currently used (BNFC) loses a lot of the information necessary for reconstructing the source program, so a pretty-printer based on the parse result is not feasible (for example, all comments would be lost). Even after this difficulty is overcome, there are still more challenges regarding the formatting itself. For example, if a given line is too long and it is necessary to wrap it by inserting a new line somewhere in the line, there are \\(O(2^n)\\) possible choices (where \\(n\\) is the number of locations in the code where a new line could be inserted) to compare between for inserting line breaks. For example, consider the following Rzk code:</p> <pre><code>#lang rzk-1\n#define id (A : U) (x : A) : A := x\n</code></pre> <p>which has 11 positions where a new line can be inserted, as shown by these markers:</p> <pre><code>#define id (A : U) (x : A) : A := x\n       ^  ^  ^ ^  ^  ^ ^  ^ ^ ^  ^\n</code></pre> <p>This amounts to 2048 combinations that have to be ranked for such a simple line. Even the ranking itself is not a straightforward problem to tackle.</p> <p>Additionally, to properly indent each line, it is necessary to understand the program semantics, which increases the complexity of the formatter's parser.</p>"},{"location":"2023/12/24/rzk-formatter/#possible-approaches-and-their-tradeoffs","title":"Possible approaches (and their tradeoffs)","text":"<p>Multiple possible solutions exist for the above difficulties, each with their pros and cons. The alternatives we considered for Rzk's formatter can be summarized as follows:</p> <ol> <li>Implement a Prettier plugin</li> <li>Reuse the existing parser generated by BNFC</li> <li>Write a dedicated parser for the formatter specifically</li> <li>Reuse the exiting lexer generated by BNFC</li> </ol>"},{"location":"2023/12/24/rzk-formatter/#prettier-plugin","title":"Prettier plugin","text":"<p>Seeing as some formalization projects were already making use of Prettier, a plugin to support Rzk seemed like a reasonable option. However, that option didn't seem so attractive for a few reasons. First of all, it would mean forcing all users to install Prettier, which requires having the JavaScript toolchain (in particular, <code>npm</code>) installed, but not all Rzk developers use JavaScript. It would be better to have an in-house solution.</p> <p>Additionally, Prettier plugins can only be written in JavaScript, which means having to maintain a separate parser written from scratch in JS, which is not maintainable or even desirable.</p>"},{"location":"2023/12/24/rzk-formatter/#bnfcs-parser","title":"BNFC's parser","text":"<p>Rzk makes use of BNFC which produces a lexer, parser, AST, and pretty-printer for a given Labelled BNF grammar file. The generated pretty-printer is not configurable, so it would take a lot of dirty patching to have it follow the style guide of Rzk code.</p> <p>As for the abstract syntax tree (AST) it generates, it is also not suitable particularly for being too abstract. It loses all information about spaces, parentheses, and basically any syntactic construction, which is useful for a compiler or typechecker, but not so much for a formatter.</p>"},{"location":"2023/12/24/rzk-formatter/#dedicated-parser","title":"Dedicated parser","text":"<p>An alternative to the generated parser would be to manually write another parser that keeps all the information relevant to the formatter in a concrete syntax tree (CST). This would be the most customizable option, but it would also be a lot of repeated work (since we already have the generated parser) that is additionally more error-prone.</p> <p>Writing a parser manually is time-consuming and redundant since it can easily be automatically generated from the much more readable grammar file.</p>"},{"location":"2023/12/24/rzk-formatter/#bnfcs-lexer","title":"BNFC's lexer","text":"<p>Since BNFC generates a lexer that is used by the parser, a more rudimentary approach would be to make use of that lexer for our formatter. As the lexer simply tokenizes the input source code, it does not make any decisions regarding what to throw away and keeps all syntax constructions (except comments). Therefore, this approach would have the least amount of syntactic information lost among the automatically generated tools.</p> <p>On the hand, working with a stream of tokens is not as easy as working with a parsed tree. First, tokens do not carry almost any semantics with them, so it is difficult to understand whether an identifier refers to a parameter, a function application, or if it's even still being declared. Also, without having semantics, it is difficult to judge out which line split would make more sense when inserting line breaks in a long line, or to figure out how much a given line should be indented.</p>"},{"location":"2023/12/24/rzk-formatter/#our-chosen-solution","title":"Our chosen solution","text":"<p>The approach that seemed the most suitable of the above was the last one: use BNFC's lexer. After going through the style guide a few times, it was clear that the vast majority of the rules/recommendations did not involve understanding much semantics. For example, Unicode replacement for ASCII sequences, moving <code>:=</code> to a new line, and adding a space after <code>\\\\</code> in a lambda term can all be applied blindly.</p> <p>For the few rules that require having some semantics (like distinguishing between <code>:</code> for definition conclusion and for other types), it was enough to just store some state that is preserved (and updated) while traversing the tokens; no additional semantic analysis was necessary.</p> <p>The actual implementation in Haskell is just pattern matching on tokens with some conditions and applying edits to the text in response. For example, the following is an excerpt of the pattern match for opening parenthesis:</p> <pre><code>-- Ensure exactly one space after the first open paren of a line\ngo :: FormatState -&gt; [Token] -&gt; [FormattingEdit]\ngo s (Token \"(\" line col : tks)\n  | precededBySingleCharOnly &amp;&amp; spacesAfter /= 1 &amp;&amp; not isLastNonSpaceChar\n    = FormattingEdit line (col + 1) line (spaceColcol + 1 + spacesAfter) \" \"\n    : go (incParensDepth s) tks\n  -- Remove extra spaces if it's *not* the first open paren on a new line\n  | not precededBySingleCharOnly &amp;&amp; spacesAfter &gt; 0\n    = FormattingEdit line (col + 1) line (col + 1 + spacesAfter) \"\"\n    : go (incParensDepth s) tks\n  | otherwise = go (incParensDepth s) tks\n  where\n    -- Redacted for brevity\n</code></pre> <p>where <code>go</code> is a helper function containing the core logic used inside <code>format :: String -&gt; String</code>. It simply operates on the current state and the matched token(s) and returns a list of edits to be applied to the text. The <code>FormattingEdit</code> structure provides compatibility with LSP (for the VS Code extension) and is easy to reuse for the CLI. Additionally, we try to make sure that these edits perform the minimal changes needed so that nothing else is affected by mistake (such as comments).</p> <p>While this implementation is more error-prone than an auto-generated pretty-printer, it is much more flexible and unit tests have been added that verify the various rules to make sure no functionality gets broken by mistake. In fact, the unit tests helped catch a bug with the formatter right as we thought we were ready to release it.</p>"},{"location":"2023/12/24/rzk-formatter/#implemented-rules","title":"Implemented rules","text":"<p>The formatter currently implements the following features:</p> <ul> <li>Add a space after the opening parenthesis to help with the code tree structure</li> <li>Put the definition conclusion (type, starting with <code>:</code>) and construction (body, starting with <code>:=</code>) on new lines</li> <li>Add a space after the <code>\\\\</code> of a lambda term and around binary operators (like <code>,</code> and <code>=</code>)</li> <li>Move binary operators to the beginning of the next line if they appear at the end of the previous one</li> <li>Replace common ASCII sequences with their Unicode equivalent</li> <li>Removes extraneous spaces in some places like before <code>)</code> or between <code>#lang</code> and <code>rzk-1</code> (though it's not comprehensive yet)</li> </ul>"},{"location":"2023/12/24/rzk-formatter/#shortcomings","title":"Shortcomings","text":"<p>No software is ever perfect, especially from the first release, and our formatter is definitely no exception \ud83d\ude42.</p> <p>For example, if the source code contained tab characters, instead of throwing its hands up in the air and angrily shouting \"I can't deal with this\", the formatter decides to silently take revenge and mess up your code by deleting random characters around the tab character, but only every once in a while! (I really wish I was joking \ud83d\ude05)</p> <p>Thankfully, the accompanying VS Code extension configures some default settings to avoid this situation by always inserting spaces.</p> <p>Aside from bugs like this, there are also features that are simply not yet implemented. For example, these include inserting line breaks in very long lines and inferring the correct indentation level a line should have. For the latter, we decided that it might be too constraining to force a specific indentation on the users when the line might be more readable using a different indentation, and the formatter is not smart enough to decide when it should adjust indentation or leave it as is.</p> <p>Lastly, some desirable features have been identified as belonging more to the linter (which we do not have yet) rather than the formatter, such as detecting unnecessary parenthesis, deprecated syntax, and expressions that could be simplified. The linter is currently not on the roadmap yet, but we hope to have it sometime in the future.</p>"},{"location":"2023/12/24/rzk-formatter/#how-to-use-the-formatter","title":"How to use the formatter","text":"<p>The formatter is shipped as part of the <code>rzk</code> executable under the subcommand <code>format</code>. It is also integrated in the language server and used by the VS Code extension. Additionally, the GitHub Action now has an option to check the formatting as well.</p>"},{"location":"2023/12/24/rzk-formatter/#cli","title":"CLI","text":"<p>The command looks like so:</p> <pre><code>rzk format [--check] [--write] [file_path]...\n</code></pre> <p>It follows the convention of other formatters (Prettier and Fourmolu, to name a couple) in that usage with any flags (<code>rzk format file.rzk</code>) outputs the result to <code>stdout</code>, using <code>--write</code> will modify the files in place, and <code>--check</code> is only for verifying that the files are already well-formatted (and exits with a non-zero code if they aren't). Naturally, <code>--write</code> and <code>--check</code> are mutually exclusive and it would be an error to specify both.</p> <p>If no file paths are given, then they will be read from <code>rzk.yaml</code> if it exists (just like with <code>typecheck</code>).</p>"},{"location":"2023/12/24/rzk-formatter/#vs-code","title":"VS Code","text":"<p>The accompanying release of the VS Code extension integrated formatter support so you can use the built-in <code>Format Document</code> command to format Rzk and Literate Rzk Markdown files. It also comes with new default settings for Rzk file that ensure consistent indentation (2 spaces), enable formatting on save, and add a ruler at 80 chars to help users identify long lines since the formatter cannot wrap them just yet.</p> <p>The formatter can be turned off manually by setting the <code>rzk.format.enable</code> option to <code>false</code>.</p>"},{"location":"2023/12/24/rzk-formatter/#github-action","title":"GitHub Action","text":"<p>A new option has been added to the <code>rzk-action</code> called <code>check-formatting</code> that, well, checks the formatting of the input files. It is off by default, and cannot be used with <code>rzk-version</code> lower than <code>v0.7.1</code>.</p>"},{"location":"2023/12/24/rzk-formatter/#conclusion-and-feedback","title":"Conclusion and Feedback","text":"<p>This was an exciting milestone for the Rzk toolset and for me personally as I have never written a similar piece of code before. That was an interesting engineering and research challenge, and I enjoyed it all the way.</p> <p>Contributions have been made to popular Rzk formalization repos to autoformat their content, such as sHoTT and the HoTT Book.</p> <p>I encourage everyone to use the formatter and help us by reporting any possible bugs on our GitHub issues page (using the label <code>formatter</code>). There also exists a Zulip thread about the autoformatter, so feedback and discussions are welcome there as well. Many thanks to Fredrik Bakke for his helpful feedback on the sHoTT formatting PR!</p> <p>See you in future blog posts :)</p>"},{"location":"archive/2023/","title":"2023","text":""},{"location":"category/announcements/","title":"Announcements","text":""}]}